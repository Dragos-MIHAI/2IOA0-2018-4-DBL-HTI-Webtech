<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  </head>
  <body>
    <script type="text/javascript">



        let input = ''
        let items = ''
        let nodes = [];
        let verticesNames = [];
        let verticesIndex = []; // We will use this later to not have to search for each index separately. This will make the running time shorter
        let links = [];
        let edges = 0;

        axios
        .get(
          "https://raw.githubusercontent.com/Dragos-MIHAI/2IOA0-2018-4-DBL-HTI-Webtech/master/GephiMatrix_co-authorship.csv"
        )
        .then(function(result) {
          input = result.data;
          input = input.slice(1,input.length);
          items = input.split(/[\s;]+/);
          console.log(items[0])
          manipulate()
          console.log(edges)
          dThree()
        });

        function manipulate() {
         let dictionaryWord = {"id": items[0]}
         nodes.push(dictionaryWord); // Add the first vertex as an object {"id": items[0]} to the nodes
         verticesNames.push(items[0]); // Push the first vertex onto the list of vertices
         verticesIndex[items[0]] = 0;
         let index = 1; // We can only start the loop now, since the first vertex will be equal to the first vertex meaning the following loop would otherwise never loop
         while (items[index] != items[0]) {
             dictionaryWord = {"id": items[index]};
             nodes.push(dictionaryWord);
             verticesNames.push(items[index]);
             verticesIndex[items[index]] = index;
             index++;
         }
         console.log(JSON.stringify(nodes))

         let vertex = items[index];
         index++;
         while (index < items.length) { // Loop through the whole items array for all the links
             for (let i = 0; i < nodes.length; i++) { // For every source vertex, we loop through all its potential adjacent vertices
                 if (items[index] != 0) { // We only create an edge if the weight is not 0
                     dictionaryWord = {"source": vertex, "target": verticesNames[i], "value": items[index]};
                     links.push(dictionaryWord);
                     edges++;
                 }
                 index++;
             }
             vertex = items[index];
             index++;

         }
         console.log(JSON.stringify(links))
        }


        var w = 1200,
            h = 800;

      function dThree() {
        var graph = d3.select("body").append("svg").style("width", "702px").style("height", "802px").style("margin-top", "50px").style("background", "one.jpg").attr("align","center");

        //properties of the object
        //upper
        //giving the graph the properties
        graph.attr("width", w)
             .attr("height", h);


         //var nodes = [{"id":"Marco"},{"id":"Lucas"},{"id":"Dragos"}];

         //var links = [{"source":"Marco","target":"Marco","value":"1"},{"source":"Marco","target":"Lucas","value":"0.6947"},{"source":"Marco","target":"Dragos","value":"0.3967"},{"source":"Lucas","target":"Marco","value":"0.6947"},{"source":"Lucas","target":"Lucas","value":"1"},{"source":"Lucas","target":"Dragos","value":"0.2850"},{"source":"Dragos","target":"Marco","value":"0.3967"},{"source":"Dragos","target":"Lucas","value":"0.2850"},{"source":"Dragos","target":"Dragos","value":"1"}];
        let attract = d3.forceManyBody().strength(40).distanceMax(10).distanceMin(10);
        let repel = d3.forceManyBody().strength(-40).distanceMax(10).distanceMin(10);

        //simulation for force directed
        var simulation = d3.forceSimulation(nodes)
              //adding link between 2 ID's
              .alphaDecay(0.03)
              .force("link", d3.forceLink(links).id(d => d.id))
              .force("attractForce", attract)
              .force("repelForce",repel)
              //making a center for the graph
              .force("center", d3.forceCenter(((w / 2)-250), (h / 2)));
              //.force("x", d3.forceX())
              //.force("y", d3.forceY());

        //adding links to the graph
        var link = graph.append("g")
              //adds stroke with #colour
              .attr("stroke", "#999")
              .attr("stroke-opacity", 0.7)
              .selectAll("line")
              .data(links)
              .enter()
              .append("line")
              //width of a line based on its value in the data
              .attr("stroke-width", d => ((d.value)));



        //adding the nodes to the graph
        var node = graph.append("g")
              .attr("stroke", "#fff")
              //width of the circle surrounding the node
              .attr("stroke-width", 1.0)
              .selectAll("circle")
              .data(nodes)
              .enter()
              .append("circle")
              .attr("r", 3)
              .attr("fill", "#FF7F50")
              //drag function
              .call(d3.drag()
                  .on("start", dragstarted)
                  .on("drag", dragged)
                  .on("end", dragended));

         //selecting data + drawing
        simulation
              .nodes(nodes)
              .on("tick", tick);


        simulation.force("link")
              .links(links);

        //assigning name to each node
        node.append("title")
              .text(d => d.id);

        //drawin the graph on the right place
        function tick() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node
              .attr("cx", function(d) { return d.x;})
              .attr("cy", function(d) { return d.y;})
        }


        //movement
        function dragstarted(d) {
          if (!d3.event.active) simulation.alphaTarget(0.4).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

        function dragged(d) {
          d.fx = d3.event.x;
          d.fy = d3.event.y;
        }

        function dragended(d) {
          if (!d3.event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        }




      }






      // Script for side navigation
      function w3_open() {
        var x = document.getElementById("mySidebar");
        x.style.width = "300px";
        x.style.paddingTop = "10%";
        x.style.display = "block";
      }

      // Close side navigation
      function w3_close() {
        document.getElementById("mySidebar").style.display = "none";
      }

      // Used to toggle the menu on smaller screens when clicking on the menu button
      function openNav() {
        var x = document.getElementById("navDemo");
        if (x.className.indexOf("w3-show") == -1) {
          x.className += " w3-show";
        } else {
          x.className = x.className.replace(" w3-show", "");
        }
      }


      //Script for audio

      var audio, mutebtn, seek_bar;
                  function initAudioPlayer(){
                    audio = new Audio();
                    audio.src = "Audio/yiruma.mp3";
                    audio.loop = true;
                    audio.load= true;
                    audio.autoplay = true;


                    // Set object references
                    mutebtn = document.getElementById("mutebtn");
                    // Add Event Handling
                    mutebtn.addEventListener("click", mute);
                    // Functions

                    function mute(){
                      if(audio.muted){
                          audio.muted = false;
                          mutebtn.style.background = "url(images_sound/speaker_2.png) no-repeat";
                        } else {
                          audio.muted = true;
                          mutebtn.style.background = "url(images_sound/speaker_muted_2.png) no-repeat";
                        }
                    }
                  }
                  window.addEventListener("load", initAudioPlayer);





      /////////////////////////////////////////////////////////////////////////////////////
      /////////////////////Add matrix/////////////////////////////////////////////////////

      let vertices = []; // The JSON object as {"id": 'vertexName'}
      		let names = []; // We want to be able to get the vertexName by means of its index
      		//let verticesIndex = {}; // We will use this later to not have to search for each index separately. This will make the running time shorter
      		let vertex = "";
      		//  let links = [];
      		let dict = {} // An object as {'vertexName' : frequency}
      		let frequencies = [] // The order of vertices by frequency
      		let frequencyMatrixColumns = [] // The matrix with columns AND rows ordered by frequency
      		let matrix = [];

      		axios
      		.get(
      		  "smallCSV"
      		)
      		.then(function(result) {
      		  	input = result.data;
      		  	input = input.slice(1,input.length);
      		  	items = input.split(/[\s;]+/);
      		  	createData();
      			Information({
      		        block : '#block',
              		data     : matrix,
      		        names    : names,
          		    colour_1 : '#FFFFFF', //colour_1 to colour_2 is the colour range
              		colour_2 : '#A60000',
      				highlight_cell_on_hover: true,
              		highlight_cell_color: '#2ecc71'
         			});
      			Information(options);
      		});

      		function transpose(m) {
        			return m[0].map((_, i) => m.map(row => row[i]));
      		}


      		function createData() { // In this function, we get the vertices, their names and their indexes. We then create a JSON file in which the links are per vertex ordered by name
      			let nodes = [];
      			let dictionaryWord = {}; // This object keeps getting added to vertices as {"id": 'vertexName'}, as a JSON file
      		    dictionaryWord = {"id": items[0]} // This will be the object we keep adding first to vertices, then with a slight change to links
      		    vertices.push(dictionaryWord);
      		    nodes.push(items[0]);
      		    verticesIndex[items[0]] = 0;
      		    let index = 1; // This was necessary because our loop invariant wouldn't hold, since the first item, items[0], obviously equals items[0]
      		    while (items[index] != items[0]) {
      		        dictionaryWord = {"id": items[index]};
      		        vertices.push(dictionaryWord);
      		        nodes.push(items[index]);
      		        index++;
      		    }
      		    //console.log(JSON.stringify(vertices)); // Uncomment for debugging

      		    vertex = items[index]; // Will contain the name of the source vertex of the links untill we went past all its adjacent vertices
      		    index++;
      			let row = []
      			let connected = false;
      			let vertexIndex = 0;
      		    while (index < items.length) {
      				row = []
      				connected = false;
      		        for (let i = 0; i < vertices.length; i++) {
      		            if (items[index] != 0) { // Checks if the weight is not 0 so that there is actually an edge
      		                dictionaryWord = {"source": vertex, "target": nodes[i], "value": items[index]}; // JSON file for links, containing source, target (from, to) and value (weight)
      						links.push(dictionaryWord);
      						connected = true
      		            }
      		            row.push(items[index]);
      		            index++;
      		        }
      		        vertex = items[index]; // After vertices.length steps, we checked all possible adjacent vertices and thus we can take the next vertex, which is now at items[index]
      				if (connected) {
      					matrix.push(row);
      				} else {
      					delete nodes[vertexIndex];
      				}
      				vertexIndex++;
      		        index++;
      			}
      			console.log(nodes);
      			let matrixColumns = [];
      			matrixColumns = transpose(matrix);
      			for (let i = nodes.length - 1; i > -1; i--) {
      				if (nodes[i] === undefined) {
      					matrixColumns.splice(i, 1);
      				}
      			}
      			matrix = transpose(matrixColumns);
      			let names = nodes.filter(function (el) {
        				return el != null;
      			});
      			console.log(names);
      			for (let i = 0; i < names.length; i++) {
      				verticesIndex[names[i]] = i;
      			}
      		    console.log(JSON.stringify(matrix)); // Uncomment for debugging
      		}

      	/*
          Information({
              block : '#block',
              data     : matrix,
              names    : names,
              colour_1 : '#FFFFFF', //colour_1 to colour_2 is the colour range
              colour_2 : '#A60000',
      		highlight_cell_on_hover: true,
              highlight_cell_color: '#2ecc71'
          });
      	*/

      		function Information(options) {
      			var margin = {top: 100, right: 100, bottom: 200, left: 100},
      			    width =500,
      			    height = 500,
      			    data = options.data,
      			    block = options.block,
      			    namesData = options.names,
      			    colour1 = options.colour_1,
      			    colour2 = options.colour_2,
      					highlightCellOnHover = options.highlight_cell_on_hover,
      		      highlightCellColor = options.highlight_cell_color;

      			var widthLegend = 100;

      		//get the minimum and maximum value of the data
      		    var maxValue = d3.max(data, function(layer) { return d3.max(layer, function(d) { return d; }); });
      		    var minValue = d3.min(data, function(layer) { return d3.min(layer, function(d) { return d; }); });

      			var numrows = data.length;
      			var numcols = data[0].length;

      		//matrix size
      			var svg = d3.select(block).append("svg")
      			    .attr("width", width + margin.left + margin.right)
      			    .attr("height", height + margin.top + margin.bottom)
      				.append("g")
      				.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
      				.call(d3.zoom().on("zoom", function () {
          				svg.attr("transform", d3.event.transform)
       				}));


      		//matrix outline
      			var background = svg.append("rect")
      			    .style("stroke", "#CA5959")
      			    .style("stroke-width", "5px")
      			    .attr("width", width)
      			    .attr("height", height);

      			var x = d3.scale.ordinal()
      			    .domain(d3.range(numcols))
      			    .rangeBands([0, width]);

      			var y = d3.scale.ordinal()
      			    .domain(d3.range(numrows))
      			    .rangeBands([0, height]);

      		//scale the colour of boxes with mininum and maximum values
      			var colorMap = d3.scale.linear()
      			    .domain([minValue,maxValue])
      			    .range([colour1, colour2]);

      			var row = svg.selectAll(".row")
      			    .data(data)
      			  	.enter().append("g")
      			    .attr("class", "row")
      			    .attr("transform", function(d, i) { return "translate(0," + y(i) + ")"; });

      			var cell = row.selectAll(".cell")
      			    .data(function(d) { return d; })
      					.enter().append("g")
      			    .attr("class", "cell")
      			    .attr("transform", function(d, i) { return "translate(" + x(i) + ", 0)"; });

      			cell.append('rect')
      			    .attr("width", x.rangeBand())
      			    .attr("height", y.rangeBand())
      			    .style("stroke-width", 0);



      //highlight cell

      					if(highlightCellOnHover){
      				cell
      				.on("mouseover", function(d) {
      						d3.select(this).style("fill", highlightCellColor);
      				})
      				.on("mouseout", function() {
      						d3.select(this).style("fill", colorMap);
      				});
      		}



      			row.selectAll(".cell")
      			    .data(function(d, i) { return data[i]; })
      			    .style("fill", colorMap);

      			var names = svg.append('g')
      				.attr('class', "names");

      			var columnLabels = names.selectAll(".column-label")
      			    .data(namesData)
      			    .enter().append("g")
      			    .attr("class", "column-label")
      			    .attr("transform", function(d, i) { return "translate(" + x(i) + "," + height + ")"; });

      			columnLabels.append("line")
      			    .attr("x1", x.rangeBand() / 2)
      			    .attr("x2", x.rangeBand() / 2)
      			    .attr("y1", 0)
      			    .attr("y2", 5);

      			columnLabels.append("text")
      			    .attr("x", -8)
      			    .attr("y", y.rangeBand() / 2)
      			    .attr("dy", ".82em")
      			    .attr("text-anchor", "end")
      			    .text(function(d, i) { return d; })
      					.attr("transform", "rotate(-45)");


      			var rowLabels = names.selectAll(".row-label")
      			    .data(namesData)
      			  .enter().append("g")
      			    .attr("class", "row-label")
      			    .attr("transform", function(d, i) { return "translate(" + 0 + "," + y(i) + ")"; });

      			rowLabels.append("line")
      			    .attr("x1", 0)
      			    .attr("x2", -5)
      			    .attr("y1", y.rangeBand() / 2)
      			    .attr("y2", y.rangeBand() / 2);

      			rowLabels.append("text")
      			    .attr("x", -8)
      			    .attr("y", y.rangeBand() / 2)
      			    .attr("dy", ".32em")
      			    .attr("text-anchor", "end")
      			    .text(function(d, i) { return d; });



      		}



    </script>
  </body>
</html>
