<!DOCTYPE html>
<html>
<head>
    <link rel="shortcut icon" type="image/x-icon" href="LOGO/favicon.png" />
<title>Visualize: Force Directed Graph</title>

<style>

/*Button audio*/
button{ border:none; cursor:pointer; outline:none; }

button#mutebtn{
	background:url(images_sound/speaker_2.png) no-repeat;
  background-position: top;
	width:34px;
	height:34px;
}

body {
        background-image: url("In website images/black.jpg ");
}

svg {

  border:1px solid rgb(0, 0, 0);

}



</style>


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://www.w3schools.com/lib/w3-theme-black.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<body id="myPage">

<!---Add matrix on the right-->
<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="style.css"/>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
	<script src="https://unpkg.com/axios/dist/axios.min.js"></script>



 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <script src="https://d3js.org/d3.v5.min.js"></script>
 <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

</head>


<!---Add matrix on the right-->

<div style="display:inline-block;" id="legend"></div>
    <div style="display:inline-block; float:right" id="block"></div>

    <aside>
      <p>Order: <select id="order">
        <option class="top-level-option" value="name">by Name</option>
        <option class="top-level-option" value="count">by Number of links</option>
        <option class="top-level-option" value="group">by Group</option>
        <option class="top-level-option" value="distance">by Distance to...</option>
      </select>
      </aside>

	<script src="https://d3js.org/d3-color.v1.min.js"></script>
	<script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
	<script src="https://d3js.org/d3-ease.v1.min.js"></script>
	<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
	<script src="https://d3js.org/d3-selection.v1.min.js"></script>
	<script src="https://d3js.org/d3-timer.v1.min.js"></script>
	<script src="https://d3js.org/d3-transition.v1.min.js"></script>
	<script src="https://d3js.org/d3-drag.v1.min.js"></script>
	<script src="https://d3js.org/d3-zoom.v1.min.js"></script>
	<script>

		var zoom = d3.zoom();

	</script>




<!-- Sidebar on click -->
<nav class="w3-sidebar w3-bar-block w3-white w3-card w3-animate-left w3-xxlarge" style="display:none;z-index:2" id="mySidebar">
    <a href="javascript:void(0)" onclick="w3_close()" class="w3-bar-item w3-button w3-display-topright w3-text-teal">Close
      <i class="fa fa-remove"></i>
    </a>
    <a href="https://www.tue.nl/en/" class="w3-bar-item w3-button">TU/e</a>
    <a href="DBL2019_NetworkVis_ProjectGuide.pdf" class="w3-bar-item w3-button">Guide</a>
    <a href="VisProjectDescription.pdf" class="w3-bar-item w3-button">Description</a>
    <a href="a.html" class="w3-bar-item w3-button">Final Report</a>
    <a href="https://canvas.tue.nl/courses/6672" class="w3-bar-item w3-button">Canvas</a>
    <a href="https://tuenl-my.sharepoint.com/:f:/g/personal/m_ungureanu1_student_tue_nl/EqKcrdCbdM5ItrNu4o3knGsBcui3yEj5oy-HUycQkuIIxA?e=JMqxPd" class="w3-bar-item w3-button">Our files</a>
  </nav>

  <!-- Navigation bar -->
  <div class="w3-top">
          <div class="w3-bar w3-theme-d2 w3-left-align">
           <a class="w3-bar-item w3-button w3-hide-medium w3-hide-large w3-right w3-hover-white w3-theme-d2" href="javascript:void(0);" onclick="openNav()"><i class="fa fa-bars"></i></a>
           <a href="index.html" class="w3-bar-item w3-button w3-teal"><i class="fa fa-home w3-margin-right"></i>VizYou</a>
           <a href="home.html" class="w3-bar-item w3-button w3-hide-small w3-hover-blue">Home</a>


             <div class="w3-dropdown-hover w3-hide-small">
             <button class="w3-button" title="Notifications">Visualization <i class="fa fa-caret-down"></i></button>
             <div class="w3-dropdown-content w3-card-4 w3-bar-block">
    
            <a href="convert.html" class="w3-bar-item w3-button">Visualize I</a> 
                <a href="convertprove.html" class="w3-bar-item w3-button">Visualize II</a>
              <a href="insert.html" class="w3-bar-item w3-button">Insert Data</a>
               <a href="vizualize.html" class="w3-bar-item w3-button">Visualize III</a>
             </div>
           </div>
           <a href="team.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Team</a>
           <a href="pricing.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Price</a>
           <a href="Contact.html" class="w3-bar-item w3-button w3-hide-small w3-hover-white">Contact</a>

          <button id="mutebtn"></button>

          <a href="#" class="w3-bar-item w3-button w3-hide-small w3-right w3-hover-teal" title="Search"><i class="fa fa-search"></i></a>
          </div>

    <!-- Navbar on small screens -->
    <div id="navDemo" class="w3-bar-block w3-theme-d2 w3-hide w3-hide-large w3-hide-medium">
      <a href="#team" class="w3-bar-item w3-button">Team</a>
      <a href="#work" class="w3-bar-item w3-button">Work</a>
      <a href="#pricing" class="w3-bar-item w3-button">Price</a>
      <a href="#contact" class="w3-bar-item w3-button">Contact</a>
      <a href="#" class="w3-bar-item w3-button">Search</a>
    </div>
  </div>




  <!-- Modal -->
  <div id="id01" class="w3-modal">
    <div class="w3-modal-content w3-card-4 w3-animate-top">
      <header class="w3-container w3-teal w3-display-container">
        <span onclick="document.getElementById('id01').style.display='none'" class="w3-button w3-teal w3-display-topright"><i class="fa fa-remove"></i></span>
        <h4>Oh snap! We just showed you a modal..</h4>
        <h5>Because we can <i class="fa fa-smile-o"></i></h5>
      </header>
      <div class="w3-container">
        <p>Cool huh? Ok, enough teasing around..</p>
        <p>Go to our <a class="w3-text-teal" href="/w3css/default.asp">W3.CSS Tutorial</a> to learn more!</p>
      </div>
      <footer class="w3-container w3-teal">
        <p>Modal footer</p>
      </footer>
    </div>
  </div>







<iframe src="Audio/silence.mp3" allow="autoplay" id="audio" style="display:none"></iframe>



<!-- Canvas graph -->

 <script>

  let input = ''
  let items = ''
  let nodes = [];
  let verticesNames = [];
  let verticesIndex = []; // We will use this later to not have to search for each index separately. This will make the running time shorter
  let links = [];
  let links2 = [];
  let edges = 0;
  let frequencyMatrix = [];

  axios
  .get(
    "https://raw.githubusercontent.com/Dragos-MIHAI/2IOA0-2018-4-DBL-HTI-Webtech/master/GephiMatrix_co-authorship.csv"
  )
  .then(function(result) {
    input = result.data;
    input = input.slice(1,input.length);
    items = input.split(/[\s;]+/);
    console.log(items[0])
    manipulate()
    console.log(edges)
    dThree()
  });

  function manipulate() {
   let dictionaryWord = {"id": items[0]};
   let dictionaryWord2 = {};
   nodes.push(dictionaryWord); // Add the first vertex as an object {"id": items[0]} to the nodes
   verticesNames.push(items[0]); // Push the first vertex onto the list of vertices
   verticesIndex[items[0]] = 0;
   let index = 1; // We can only start the loop now, since the first vertex will be equal to the first vertex meaning the following loop would otherwise never loop
   while (items[index] != items[0]) {
       dictionaryWord = {"id": items[index]};
       nodes.push(dictionaryWord);
       verticesNames.push(items[index]);
       verticesIndex[items[index]] = index;
       index++;
   }
   console.log(JSON.stringify(nodes))

   let vertex = items[index];
   index++;
   while (index < items.length) { // Loop through the whole items array for all the links
       for (let i = 0; i < nodes.length; i++) { // For every source vertex, we loop through all its potential adjacent vertices
           if (items[index] != 0) { // We only create an edge if the weight is not 0
               dictionaryWord = {"source": vertex, "target": verticesNames[i], "value": items[index]};
               dictionaryWord2 = {"source": verticesIndex[vertex], "target":verticesIndex[i]};
               links.push(dictionaryWord);
               links2.push(dictionaryWord2)
               edges++;
           }
           index++;
       }
       vertex = items[index];
       index++;

   }
   console.log(JSON.stringify(links2))
  }

  function getFrequency() { // This function counts the amount of adjacent vertices per vertex and creates a matrix
    let row = []; // Is added to the matrix as a new row when finished 
    let index = verticesNames.length + 1; // Iterator over the whole vertices array
    for (let i = 1; i < vertices.length; i++) { // We count the links for every vertex, so we iterate over the verticesNames array
        dict[verticesNames[i - 1]] = 0; // Gotta start at 0
        while (items[index] != items[i]) {
            if (items[index] != 0) {
                dict[verticesNames[i - 1]]++; // If there is a weight, frequency is increased by 1 for that vertex
            }
            index++;
        }
        index++;
    }
    row = []; // The code below here is added because we keep checking the vertex in advance, but there is no next vertex for the last vertex. Therefore, this is taken out of the loop, since the loop invariant wouldn't hold
    dict[verticesNames[verticesNames.length - 1]] = 0;
    while (index < items.length) {
        if (items[index] != 0) {
            dict[verticesNames[verticesNames.length - 1]]++;
        }
        index++;
    }

    frequencies = sortVertices(verticesNames); // Here we order the vertices by frequency by using mergesort in the form index: 'vertexName'
    frequencyMatrixRows = matrix.slice(0, matrix.length); // We first have to order the rows. Columns remain in the old order

    for (let i = 0; i < frequencies.length; i++) {
        frequencyMatrixRows[i] = matrix[verticesIndex[frequencies[i]]];
    }
    frequencyMatrixColumns = transpose(frequencyMatrixRows) // Now we order the columns accordingly
    for (let i = 0; i < frequencies.length; i++) {
        for (let j = 0; j < frequencyMatrixRows.length; j++) {
            frequencyMatrixColumns[j][i] = frequencyMatrixRows[j][verticesIndex[frequencies[i]]] // Add the nth frequency to the frequencyMatrix by accessing the old index of that vertex
        }
        verticesIndex[frequencies[i]] = i // Then update this vertex to its new vertex, i
    }
    frequencyMatrix = transpose(frequencyMatrixColumns);
}

function transpose(m) { // Used to transpose matrices
  return m[0].map((_, i) => m.map(row => row[i]));
}

function sortVertices(names) {
    if (names.length === 1) {
        return names;
    } else {
        const middle = Math.floor(names.length/2);
        const left = names.slice(0, middle);
        const right = names.slice(middle);

        return(merge(
            sortVertices(left), // recurseLeft()
            sortVertices(right) // recurseRight()
        ))
    }
}

// The mergesort algorithm, called upon by sortVertices. This is specialised for frequency. 
function merge(left, right) {
    let result = [];
    let indexLeft = 0
    let indexRight = 0
    while (indexLeft < left.length && indexRight < right.length) { // We iterate over both arrays and keep comparing the 2 elements untill all elements have been checked of one array. 
        if (dict[left[indexLeft]] > dict[right[indexRight]]) { // If the element in the left is bigger, we push that and take the left array's next element
            result.push(left[indexLeft])
            indexLeft++
        } else { // Else we push the element of the right array and take its next element
            result.push(right[indexRight])
            indexRight++
        }
    }
    return(result.concat(left.slice(indexLeft)).concat(right.slice(indexRight))); // We have to connect the leftovers
}
   

  var w = 1200,
      h = 800;

function dThree() {
  var graph = d3.select("body").append("svg").style("width", "702px").style("height", "802px").style("margin-top", "50px").style("background", "one.jpg").attr("align","center");

  //properties of the object
  //upper
  //giving the graph the properties
  graph.attr("width", w)
       .attr("height", h);
       //.call(d3.zoom().on("zoom", function () {
    	//			graph.attr("transform", d3.event.transform)
 				//}));
       
   //var nodes = [{"id":"Marco"},{"id":"Lucas"},{"id":"Dragos"}];

   //var links = [{"source":"Marco","target":"Marco","value":"1"},{"source":"Marco","target":"Lucas","value":"0.6947"},{"source":"Marco","target":"Dragos","value":"0.3967"},{"source":"Lucas","target":"Marco","value":"0.6947"},{"source":"Lucas","target":"Lucas","value":"1"},{"source":"Lucas","target":"Dragos","value":"0.2850"},{"source":"Dragos","target":"Marco","value":"0.3967"},{"source":"Dragos","target":"Lucas","value":"0.2850"},{"source":"Dragos","target":"Dragos","value":"1"}];
  let attract = d3.forceManyBody().strength(40).distanceMax(10).distanceMin(10);//Dragos
  let repel = d3.forceManyBody().strength(-40).distanceMax(10).distanceMin(10);//Dragos

  //simulation for force directed
  var simulation = d3.forceSimulation(nodes)
        //adding link between 2 ID's
        .alphaDecay(0.03)
        .force("link", d3.forceLink(links).id(d => d.id))
        .force("attractForce", attract)
        .force("repelForce",repel)
        //making a center for the graph
        .force("center", d3.forceCenter(((w / 2)-250), (h / 2)));
        //.force("x", d3.forceX())//Dragos
        //.force("y", d3.forceY());//Dragos

  //adding links to the graph
  var link = graph.append("g")
        //adds stroke with #colour
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.7)
        .selectAll("line")
        .data(links)
        .enter()
        .append("line")
        //width of a line based on its value in the data
        .attr("stroke-width", d => ((d.value)));



  //adding the nodes to the graph
  var node = graph.append("g")
        .attr("stroke", "#fff")
        //width of the circle surrounding the node
        .attr("stroke-width", 1.0)
        .selectAll("circle")
        .data(nodes)
        .enter()
        .append("circle")
        .attr("r", 3)
        .attr("fill", "#FF7F50")
        //drag function
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

   //selecting data + drawing
  simulation
        .nodes(nodes)
        .on("tick", tick);


  simulation.force("link")
        .links(links);

  //assigning name to each node
  node.append("title")
        .text(d => d.id);

  //drawin the graph on the right place
  function tick() {
      link
          .attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      node
        .attr("cx", function(d) { return d.x;})
        .attr("cy", function(d) { return d.y;})
  }


  //movement
  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.4).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
}

// Script for side navigation
function w3_open() {
  var x = document.getElementById("mySidebar");
  x.style.width = "300px";
  x.style.paddingTop = "10%";
  x.style.display = "block";
}

// Close side navigation
function w3_close() {
  document.getElementById("mySidebar").style.display = "none";
}

// Used to toggle the menu on smaller screens when clicking on the menu button
function openNav() {
  var x = document.getElementById("navDemo");
  if (x.className.indexOf("w3-show") == -1) {
    x.className += " w3-show";
  } else {
    x.className = x.className.replace(" w3-show", "");
  }
}


//Script for audio

var audio, mutebtn, seek_bar;
            function initAudioPlayer(){
              audio = new Audio();
              audio.src = "Audio/yiruma.mp3";
              audio.loop = true;
              audio.load= true;
              audio.autoplay = true;


              // Set object references
              mutebtn = document.getElementById("mutebtn");
              // Add Event Handling
              mutebtn.addEventListener("click", mute);
              // Functions

              function mute(){
                if(audio.muted){
                    audio.muted = false;
                    mutebtn.style.background = "url(images_sound/speaker_2.png) no-repeat";
                  } else {
                    audio.muted = true;
                    mutebtn.style.background = "url(images_sound/speaker_muted_2.png) no-repeat";
                  }
              }
            }
            window.addEventListener("load", initAudioPlayer);

/////////////////////////////////////////////////////////////////////////////////////
/////////////////////Add matrix/////////////////////////////////////////////////////

let vertices = []; // The JSON object as {"id": 'vertexName'}
		let names = []; // We want to be able to get the vertexName by means of its index
		//let verticesIndex = {}; // We will use this later to not have to search for each index separately. This will make the running time shorter
		let vertex = "";
		//  let links = [];
		let dict = {} // An object as {'vertexName' : frequency}
		let frequencies = [] // The order of vertices by frequency
		let frequencyMatrixColumns = [] // The matrix with columns AND rows ordered by frequency
		let matrix = [];

		axios
		.get(
		  "https://raw.githubusercontent.com/Dragos-MIHAI/2IOA0-2018-4-DBL-HTI-Webtech/master/smallCSV"
		)
		.then(function(result) {
		  	input = result.data;
		  	input = input.slice(1,input.length);
		  	items = input.split(/[\s;]+/);
		  	createData();
			Information({
		        block : '#block',
        		data     : matrix,
		        names    : names,
    		    colour_1 : '#FFFFFF', //colour_1 to colour_2 is the colour range
        		colour_2 : '#A60000',
				highlight_cell_on_hover: true,
        		highlight_cell_color: '#2ecc71'
   			});
			Information(options);
		});

		function transpose(m) {
  			return m[0].map((_, i) => m.map(row => row[i]));
		}


		function createData() { // In this function, we get the vertices, their names and their indexes. We then create a JSON file in which the links are per vertex ordered by name
			let nodes = [];
			let dictionaryWord = {}; // This object keeps getting added to vertices as {"id": 'vertexName'}, as a JSON file
		    dictionaryWord = {"id": items[0]} // This will be the object we keep adding first to vertices, then with a slight change to links
		    vertices.push(dictionaryWord);
		    nodes.push(items[0]);
		    verticesIndex[items[0]] = 0;
		    let index = 1; // This was necessary because our loop invariant wouldn't hold, since the first item, items[0], obviously equals items[0]
		    while (items[index] != items[0]) {
		        dictionaryWord = {"id": items[index]};
		        vertices.push(dictionaryWord);
		        nodes.push(items[index]);
		        index++;
		    }
		    //console.log(JSON.stringify(vertices)); // Uncomment for debugging

		    vertex = items[index]; // Will contain the name of the source vertex of the links untill we went past all its adjacent vertices
		    index++;
			let row = []
			let connected = false;
			let vertexIndex = 0;
		    while (index < items.length) {
				row = []
				connected = false;
		        for (let i = 0; i < vertices.length; i++) {
		            if (items[index] != 0) { // Checks if the weight is not 0 so that there is actually an edge
		                dictionaryWord = {"source": vertex, "target": nodes[i], "value": items[index]}; // JSON file for links, containing source, target (from, to) and value (weight)
						links.push(dictionaryWord);
						connected = true
		            }
		            row.push(items[index]);
		            index++;
		        }
		        vertex = items[index]; // After vertices.length steps, we checked all possible adjacent vertices and thus we can take the next vertex, which is now at items[index]
				if (connected) {
					matrix.push(row);
				} else {
					delete nodes[vertexIndex];
				}
				vertexIndex++;
		        index++;
			}
			console.log(nodes);
			let matrixColumns = [];
			matrixColumns = transpose(matrix);
			for (let i = nodes.length - 1; i > -1; i--) {
				if (nodes[i] === undefined) {
					matrixColumns.splice(i, 1);
				}
			}
			matrix = transpose(matrixColumns);
			let names = nodes.filter(function (el) {
  				return el != null;
			});
			console.log(names);
			for (let i = 0; i < names.length; i++) {
				verticesIndex[names[i]] = i;
			}
		    console.log(JSON.stringify(matrix)); // Uncomment for debugging
		}

	/*
    Information({
        block : '#block',
        data     : matrix,
        names    : names,
        colour_1 : '#FFFFFF', //colour_1 to colour_2 is the colour range
        colour_2 : '#A60000',
		highlight_cell_on_hover: true,
        highlight_cell_color: '#2ecc71'
    });
	*/

		function Information(options) {
			var margin = {top: 100, right: 100, bottom: 200, left: 100},
			    width =500,
			    height = 500,
			    data = options.data,
			    block = options.block,
			    namesData = options.names,
			    colour1 = options.colour_1,
			    colour2 = options.colour_2,
					highlightCellOnHover = options.highlight_cell_on_hover,
		      highlightCellColor = options.highlight_cell_color;

			var widthLegend = 100;

		//get the minimum and maximum value of the data
		    var maxValue = d3.max(data, function(layer) { return d3.max(layer, function(d) { return d; }); });
		    var minValue = d3.min(data, function(layer) { return d3.min(layer, function(d) { return d; }); });

			var numrows = data.length;
			var numcols = data[0].length;

		//matrix size
			var svg = d3.select(block).append("svg")
			    .attr("width", width + margin.left + margin.right)
			    .attr("height", height + margin.top + margin.bottom)
				.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")")
				.call(d3.zoom().on("zoom", function () {
    				svg.attr("transform", d3.event.transform)
 				}));

		//matrix outline
			var background = svg.append("rect")
			    .style("stroke", "#CA5959")
			    .style("stroke-width", "5px")
			    .attr("width", width)
			    .attr("height", height);

			var x = d3.scale.ordinal()
			    .domain(d3.range(numcols))
			    .rangeBands([0, width]);

			var y = d3.scale.ordinal()
			    .domain(d3.range(numrows))
			    .rangeBands([0, height]);

		//scale the colour of boxes with mininum and maximum values
			var colorMap = d3.scale.linear()
			    .domain([minValue,maxValue])
			    .range([colour1, colour2]);

			var row = svg.selectAll(".row")
			    .data(data)
			  	.enter().append("g")
			    .attr("class", "row")
			    .attr("transform", function(d, i) { return "translate(0," + y(i) + ")"; });

			var cell = row.selectAll(".cell")
			    .data(function(d) { return d; })
					.enter().append("g")
			    .attr("class", "cell")
			    .attr("transform", function(d, i) { return "translate(" + x(i) + ", 0)"; });

			cell.append('rect')
			    .attr("width", x.rangeBand())
			    .attr("height", y.rangeBand())
			    .style("stroke-width", 0);



//highlight cell

					if(highlightCellOnHover){
				cell
				.on("mouseover", function(d) {
						d3.select(this).style("fill", highlightCellColor);
				})
				.on("mouseout", function() {
						d3.select(this).style("fill", colorMap);
				});
		}



			row.selectAll(".cell")
			    .data(function(d, i) { return data[i]; })
			    .style("fill", colorMap);

			var names = svg.append('g')
				.attr('class', "names");

			var columnLabels = names.selectAll(".column-label")
			    .data(namesData)
			    .enter().append("g")
			    .attr("class", "column-label")
			    .attr("transform", function(d, i) { return "translate(" + x(i) + "," + height + ")"; });

			columnLabels.append("line")
			    .attr("x1", x.rangeBand() / 2)
			    .attr("x2", x.rangeBand() / 2)
			    .attr("y1", 0)
			    .attr("y2", 5);

			columnLabels.append("text")
			    .attr("x", -8)
			    .attr("y", y.rangeBand() / 2)
			    .attr("dy", ".82em")
			    .attr("text-anchor", "end")
			    .text(function(d, i) { return d; })
					.attr("transform", "rotate(-45)");


			var rowLabels = names.selectAll(".row-label")
			    .data(namesData)
			  .enter().append("g")
			    .attr("class", "row-label")
			    .attr("transform", function(d, i) { return "translate(" + 0 + "," + y(i) + ")"; });

			rowLabels.append("line")
			    .attr("x1", 0)
			    .attr("x2", -5)
			    .attr("y1", y.rangeBand() / 2)
			    .attr("y2", y.rangeBand() / 2);

			rowLabels.append("text")
			    .attr("x", -8)
			    .attr("y", y.rangeBand() / 2)
			    .attr("dy", ".32em")
			    .attr("text-anchor", "end")
			    .text(function(d, i) { return d; });



		}




 </script>



</body>
</html>
